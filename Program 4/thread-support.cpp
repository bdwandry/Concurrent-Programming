/* ----------------------------------------------------------- */
/* NAME : Bryan Wandrych                     User ID: bdwandry */
/* DUE DATE : 12/4/2021                                        */
/* PROGRAM ASSIGNMENT 4                                        */
/* FILE NAME : thread.h                                        */
/* PROGRAM PURPOSE : The purpose of this program is to solve   */
/* the Party Problem by implementing 2 different types of      */
/* threads, students and landlord. Students                    */
/* will join/leave a room freely. However, if the landlord     */
/* appears at a random time and the room is over capacity, they*/
/* will remove everyone from that room. This file contains     */
/* all of the logic to the Students and Landlord.              */
/* ----------------------------------------------------------- */
#include <iostream>
#include "thread.h"
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
using namespace std;

/* ----------------------------------------------------------- */
/* FUNCTION: GoToParty                                         */
/*    This is an extension of Thread.cpp. It will aid in the   */
/*    logic behind the Student threads generated by this       */
/*    algorithm. 	                                           */
/* PARAMETER USAGE :                                           */
/*    N/A                                                      */
/* FUNCTION CALLED :                                           */
/*    StudentsThread                                           */
/* ----------------------------------------------------------- */
int StudentsThread::GoToParty() {
	//------------------------------------------------------------------
	//Enters Room
	//Mutex locking: If a student wants to enter the room.
	Delay();
	PtrLck.Lock();
		printf("     Student %d waits to enter the room\n",  studentID + 1);
	PtrLck.Unlock();
	
	//Adds some randomized delay
	for (int i = 0; i < 5; i++) {
		Delay();
	}
	//Mutex Locking: The student tries to enters the room.
	EntSem.Wait();
		PtrLck.Lock();
			StudentsThread::studentsInRoom++;
			printf("     Student %d enters the room (%d students in the room) \n",  studentID + 1, StudentsThread::studentsInRoom);
		PtrLck.Unlock();
	EntSem.Signal();
	//Adds some randomized delay
	for (int i = 0; i < (StudentsThread::studentsInRoom); i++) {
		Delay();
	}
	//------------------------------------------------------------------
	//Leaves Room
	//Mutex Locking: The student is getting ready to leave the room.	
	PtrLck.Lock();
		printf("     Student %d waits to leave the room\n", studentID + 1);
	PtrLck.Unlock();
	
	//Mutex Locking: The student is getting ready to leave the room.
	ExSem.Wait();
		PtrLck.Lock();
			StudentsThread::studentsInRoom--;
			printf("     Student %d leaves the room (%d students in the room)\n",  studentID + 1, StudentsThread::studentsInRoom);
		PtrLck.Unlock();
	ExSem.Signal();
	return 1;
}

/* ----------------------------------------------------------- */
/* FUNCTION: CheckRoom                                         */
/*    This is an extension of Thread.cpp. It will aid in the   */
/*    logic behind the Landlord threads generated by this      */
/*    algorithm. 	                                           */
/* PARAMETER USAGE :                                           */
/*    N/A                                                      */
/* FUNCTION CALLED :                                           */
/*    LandLordThread                                           */
/* ----------------------------------------------------------- */
int LandLordThread::CheckRoom() {
	//Mutex Lock: Landlord has officially Entered the room
	//Blocks all students from entering and leaving.
	EntSem.Wait();
	ExSem.Wait();
	
	PtrLck.Lock();
			printf("The landlord checks the room the %d time\n",  iteration + 1);
			//printf("Number of Current Students: %d; Capacity of Room: %d\n", StudentsThread::studentsInRoom, capacity);
	PtrLck.Unlock();
	
	//Landlord Enters - Checks to see if the room is empty
	if (StudentsThread::studentsInRoom == 0) {
		PtrLck.Lock();
			printf("The landlord finds the room has no students and leaves\n");
		PtrLck.Unlock();
		EntSem.Signal();
		ExSem.Signal();
	} 
	
	//Landlord Enters - Checks to see if there are more people greater than the given capacity (i.e. n >= k)
	else if (StudentsThread::studentsInRoom >= capacity) {
		PtrLck.Lock();
			printf("The landlord finds %d students in the room and breaks up the party\n", StudentsThread::studentsInRoom);
		PtrLck.Unlock();
		PtrLck.Lock();
			printf("The landlord finishes checking and forces everyone to leave\n");
		PtrLck.Unlock();
		ExSem.Signal();
		while(StudentsThread::studentsInRoom != 0) {
			Delay();
		}
		PtrLck.Lock();
			printf("The landlord leaves the room and the room is empty\n");
		PtrLck.Unlock();
		EntSem.Signal();
	}
	//Landlord Enters - Checks to see if there are less people than the given capacity (i.e. n < k)
	else if (StudentsThread::studentsInRoom < capacity) {
		PtrLck.Lock();
			printf("The landlord finds there are %d students in the room (condition being good) and leaves.\n", StudentsThread::studentsInRoom);
		PtrLck.Unlock();
		EntSem.Signal();
		ExSem.Signal();
	}
	return 1;
}